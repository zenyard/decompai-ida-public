import hashlib
import json
import typing as ty

import ida_funcs
import ida_hexrays
import ida_name
import ida_segment
import idautils
import typing_extensions as tye
from idaapi import BADADDR
from more_itertools import ilen, take

from decompai_client import AddressDetail, RangeDetail
from decompai_client.models import Function, Thunk
from decompai_ida import api, ida_tasks, inferences, lines, state
from decompai_ida.model import transform_code

_IGNORED_SEGMENTS = {
    "extern",
    ".plt",
    ".plt.got",
    ".got",
    # TODO: PE, Mach-O segments?
}


_MAX_INSTRUCTIONS_TO_DECOMPILE = 0x2000
"""
Skip decompiling functions larger than this. These may cause decompiler to hang for a
long time, and will probably be too large for model.
"""

# An object. The `Object` generated by OpenAPI generator is harder to use since
# it allows for `None`.
Object: tye.TypeAlias = ty.Union[Function, Thunk]


# Note - decompiling a function actually requires writing to the DB, probably to
# cache results. Using `read` here results in failed decompilations.
@ida_tasks.wrap
def read_object(address: int) -> Object:
    """
    Read object at address.

    If `func_graph` is available, it will be used to avoid traversing the
    function for calls.
    """
    func = ida_funcs.get_func(address)
    assert func is not None
    assert func.start_ea == address

    is_thunk = bool(func.flags & ida_funcs.FUNC_THUNK)

    # TODO: maybe we want short/demangled name
    name = ida_name.get_name(address)

    inference_seq_number = _get_inference_seq_number_sync()

    if is_thunk:
        target, _ = ida_funcs.calc_thunk_func_target(func)
        if target == BADADDR:
            raise Exception("Can't find thunk target")

        return Thunk(
            address=api.format_address(address),
            name=name,
            target=api.format_address(target),
            inference_seq_number=inference_seq_number,
        )

    else:
        if _is_too_big_to_decompile(address):
            raise Exception("Not decompiling, too big")

        failure = ida_hexrays.hexrays_failure_t()
        decompiled = ida_hexrays.decompile_func(
            func,
            failure,
            ida_hexrays.DECOMP_NO_WAIT | ida_hexrays.DECOMP_NO_CACHE,
        )

        if decompiled is None:
            raise Exception(f"Can't decompile: {failure.desc()}")
        code = str(decompiled)

        has_known_name = inferences.has_user_defined_name.sync(address)

        return Function(
            address=api.format_address(address),
            name=name,
            code=code,
            calls=_get_calls_sync(address),
            has_known_name=has_known_name,
            ranges=list(lines.get_ranges.sync(decompiled)),
            inference_seq_number=inference_seq_number,
        )


@ida_tasks.wrap
def hash_object(obj: Object) -> bytes:
    if isinstance(obj, Function):
        obj = _reduct_object_references_from_code_sync(obj)

    obj = _reduct_inference_seq_number(obj)

    data = json.dumps(
        obj.model_dump(mode="json"),
        ensure_ascii=False,
        separators=(",", ":"),
        sort_keys=True,
    ).encode("utf-8")

    return hashlib.blake2b(data, digest_size=8).digest()


@ida_tasks.wrap
def is_in_ignored_segment(address: int) -> bool:
    segment = ida_segment.getseg(address)

    if ida_segment.get_segm_class(segment) != "CODE":
        return True

    if ida_segment.get_segm_name(segment) in _IGNORED_SEGMENTS:
        return True

    return False


def _get_inference_seq_number_sync() -> ty.Optional[int]:
    ida_tasks.assert_running_in_task()

    # Inference sequence number is cursor minus one.
    revision_cursor = state.get_revision_cursor.sync()
    return revision_cursor - 1 if revision_cursor is not None else None


def _get_calls_sync(address: int) -> list[str]:
    ida_tasks.assert_running_in_task()

    results = set[int]()
    for item in idautils.FuncItems(address):
        for code_ref in idautils.CodeRefsFrom(item, flow=False):
            func = ida_funcs.get_func(code_ref)
            if func is None or func.start_ea == address:
                continue
            results.add(func.start_ea)
    return [api.format_address(result) for result in results]


def _is_too_big_to_decompile(address: int) -> int:
    return (
        ilen(take(_MAX_INSTRUCTIONS_TO_DECOMPILE, idautils.FuncItems(address)))
        == _MAX_INSTRUCTIONS_TO_DECOMPILE
    )


def _reduct_object_references_from_code_sync(func: Function) -> Function:
    """
    Gets code but replaces all references to other objects with `[obj]`.

    This is useful for hashing, so that changing other objects doesn't change
    change of this object.
    """
    ida_tasks.assert_running_in_task()

    def reduct_object_reference(original: str, detail: RangeDetail):
        if (
            isinstance(detail.actual_instance, AddressDetail)
            and (detail.actual_instance.address != func.address)
            and _is_object_address_sync(
                api.parse_address(detail.actual_instance.address)
            )
        ):
            return "[obj]"
        else:
            return original

    return transform_code(func, reduct_object_reference)


def _reduct_inference_seq_number(obj: Object) -> Object:
    return obj.model_copy(update={"inference_seq_number": 0})


def _is_object_address_sync(address: int) -> bool:
    ida_tasks.assert_running_in_task()

    func = ida_funcs.get_func(address)

    if func is None or address != func.start_ea:
        return False

    if is_in_ignored_segment.sync(address):
        return False

    return True
